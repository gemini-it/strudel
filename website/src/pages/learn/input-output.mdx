---
title: MIDI, OSC & MQTT
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# MIDI, OSC et MQTT

Normalement, Strudel est utilisé pour patteriser le son, en utilisant son propre synthétiseur basé sur '[web audio](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)' appelé [SuperDough](https://codeberg.org/uzu/strudel/src/branch/main/packages/superdough).

Il est également possible de patteriser d'autres choses avec Strudel, comme des synthétiseurs logiciels et matériels avec MIDI, d'autres logiciels utilisant Open Sound Control/OSC (y compris le synthétiseur [SuperDirt](https://github.com/musikinformatik/SuperDirt/) couramment utilisé avec le frère de Strudel [TidalCycles](https://tidalcycles.org/)), ou le protocole 'internet des objets' MQTT.

# MIDI

Strudel prend en charge MIDI sans aucun logiciel supplémentaire (grâce à [webmidi](https://npmjs.com/package/webmidi)), simplement en ajoutant des méthodes à votre pattern :

## midiin(inputName?)

<JsDoc client:idle name="midin" h={0} />

## midi(outputName?,options?)

Connectez soit un périphérique MIDI ou utilisez le pilote IAC (Mac) ou le port Midi Through (Linux) pour les messages MIDI internes.
Si aucun outputName n'est donné, il utilise la première sortie MIDI qu'il trouve.

<MiniRepl
  client:idle
  tune={`
$: chord("<C^7 A7 Dm7 G7>").voicing().midi('IAC Driver')
`}
/>

Dans la console, vous verrez un log des périphériques MIDI disponibles dès que vous exécutez le code,
par exemple

```
 `Midi connected! Using "Midi Through Port-0".`
```

La fonction `.midi()` accepte un objet d'options avec les propriétés suivantes :

<MiniRepl
  client:idle
  tune={`$: note("d e c a f").midi('IAC Driver', { isController: true, midimap: 'default'})
`}
/>

<details>
<summary>Options disponibles</summary>

| Option       | Type          | Défaut    | Description                                                                   |
| ------------ | ------------- | --------- | ----------------------------------------------------------------------------- |
| isController | boolean       | false     | Lorsque true, désactive l'envoi de messages de notes. Utile pour contrôleurs MIDI |
| latencyMs    | number        | 34        | Latence en millisecondes pour aligner MIDI avec le moteur audio               |
| noteOffsetMs | number        | 10        | Décalage en millisecondes pour les messages note-off pour éviter les glitchs  |
| midichannel  | number        | 1         | Canal MIDI par défaut (1-16)                                                   |
| velocity     | number        | 0.9       | Vélocité de note par défaut (0-1)                                              |
| gain         | number        | 1         | Multiplicateur de gain par défaut pour la vélocité (0-1)                       |
| midimap      | string        | 'default' | Nom du mapping MIDI à utiliser pour les changements de contrôle               |
| midiport     | string/number | -         | Nom ou index du périphérique MIDI                                              |

</details>

### midiport(outputName)

Sélectionne le périphérique de sortie MIDI à utiliser, le pattern peut être utilisé pour basculer entre les périphériques.

```javascript
$: midiport('IAC Driver');
$: note('c a f e').midiport('<0 1 2 3>').midi();
```

<JsDoc client:idle name="midiport" h={0} />

## midichan(number)

Sélectionne le canal MIDI à utiliser. Si non utilisé, `.midi` utilisera le canal 1 par défaut.

## midicmd(command)

`midicmd` envoie des messages système MIDI en temps réel pour contrôler le timing et le transport sur les périphériques MIDI.

Il prend en charge les commandes suivantes :

- `clock`/`midiClock` - Envoie des messages d'horloge de timing MIDI
- `start` - Envoie un message de démarrage MIDI
- `stop` - Envoie un message d'arrêt MIDI
- `continue` - Envoie un message de continuation MIDI

// Vous pouvez contrôler l'horloge avec un pattern et vous assurer qu'elle démarre en synchronisation lorsque le repl commence.
// Remarque : Il pourrait agir de manière inattendue si MIDI n'est pas configuré initialement.

<MiniRepl
  client:idle
  tune={`$:stack(
  midicmd("clock*48,<start stop>/2").midi('IAC Driver')
)`}
/>

## control, ccn && ccv

- `control` envoie des messages de changement de contrôle MIDI à votre périphérique MIDI.
- `ccn` définit le numéro cc. Dépend du mapping MIDI de votre synthé
- `ccv` définit la valeur cc. normalisée de 0 à 1.

<MiniRepl client:idle tune={`note("c a f e").control([74, sine.slow(4)]).midi()`} />

<MiniRepl client:idle tune={`note("c a f e").ccn(74).ccv(sine.slow(4)).midi()`} />

Dans l'extrait ci-dessus, `ccn` est défini sur 74, qui est la coupure de filtre pour de nombreux synthés. `ccv` est contrôlé par un pattern saw.
Ayant tout dans un pattern, le pattern `ccv` sera aligné avec le pattern de notes, car la structure vient de la gauche par défaut.
Mais vous pouvez également contrôler les messages cc séparément comme ceci :

<MiniRepl
  client:idle
  tune={`$: note("c a f e").midi()
$: ccv(sine.segment(16).slow(4)).ccn(74).midi()`}
/>

Au lieu de définir `ccn` et `ccv` directement, vous pouvez également créer des mappings avec `midimaps` :

## midimaps

<JsDoc client:idle name="midimaps" h={0} />

## defaultmidimap

<JsDoc client:idle name="defaultmidimap" h={0} />

## progNum (Program Change)

`progNum` envoie des messages de changement de programme MIDI pour basculer entre différents presets/patches sur votre périphérique MIDI.
Les valeurs de changement de programme doivent être des nombres entre 0 et 127.

<MiniRepl client:idle tune={`// Basculer entre les programmes 0 et 1 à chaque cycle
progNum("<0 1>").midi()

// Jouer des notes tout en changeant de programmes
note("c3 e3 g3").progNum("<0 1 2>").midi()`} />

Les messages de changement de programme sont utiles pour basculer entre différents sons d'instruments ou presets pendant une performance.
Le son exact auquel chaque numéro de programme correspond dépend de la configuration de votre périphérique MIDI.

## sysex, sysexid && sysexdata (Message System Exclusive)

`sysex` envoie des messages MIDI System Exclusive (SysEx) à votre périphérique MIDI.
Les messages SysEx sont des commandes spécifiques au périphérique qui permettent un contrôle plus profond sur les paramètres du synthétiseur.
La valeur doit être un tableau de nombres entre 0-255 représentant les octets de données SysEx.

<MiniRepl
  client:idle
  tune={`// Envoyer un message SysEx simple
let id = 0x43; //Yamaha
//let id = "0x00:0x20:0x32"; //L'ID Behringer peut être un tableau de nombres
let data = "0x79:0x09:0x11:0x0A:0x00:0x00"; // Définir la voix NSX-39 pour dire "Aa"
$: note("c a f e").sysex(id, data).midi();
$: note("c a f e").sysexid(id).sysexdata(data).midi();`}
/>

Le format exact des messages SysEx dépend de la spécification de votre périphérique MIDI.
Consultez le guide d'implémentation MIDI de votre périphérique pour plus de détails sur les messages SysEx pris en charge.

## midibend && miditouch

`midibend` définit le pitch bend MIDI (-1 - 1)
`miditouch` définit le key after touch MIDI (0-1)

<MiniRepl client:idle tune={`note("c a f e").midibend(sine.slow(4).range(-0.4,0.4)).midi()`} />

<MiniRepl client:idle tune={`note("c a f e").miditouch(sine.slow(4).range(0,1)).midi()`} />

# OSC/SuperDirt/StrudelDirt

Dans TidalCycles, le son est généralement généré en utilisant [SuperDirt](https://github.com/musikinformatik/SuperDirt/), qui s'exécute dans SuperCollider. Strudel prend également en charge l'utilisation de SuperDirt, bien que cela nécessite l'installation de logiciels supplémentaires.

Il existe également [StrudelDirt](https://github.com/daslyfe/StrudelDirt) qui est SuperDirt avec quelques optimisations pour travailler avec Strudel. (Un objectif à plus long terme est de fusionner ces optimisations dans la version principale de SuperDirt)

## Prérequis

Pour faire fonctionner SuperDirt avec Strudel, vous devez

1. installer SuperCollider + plugins sc3, voir [Tidal Docs](https://tidalcycles.org/docs/) (Install Tidal) pour plus d'informations.
2. installer SuperDirt, ou le fork [StrudelDirt](https://github.com/daslyfe/StrudelDirt) qui est optimisé pour une utilisation avec Strudel
3. installer [node.js](https://nodejs.org/en/)
4. télécharger le [dépôt Strudel](https://codeberg.org/uzu/strudel/) (ou git clone, si vous avez git installé)
5. exécuter `pnpm i` dans le répertoire strudel
6. exécuter `pnpm run osc` pour démarrer le serveur OSC, qui transfère les messages OSC du REPL Strudel vers SuperCollider

Vous êtes maintenant prêt !

## Utilisation

1. Démarrez SuperCollider, soit en utilisant SuperCollider IDE, soit en exécutant `sclang` dans un terminal
2. Ouvrez le [Strudel REPL](https://strudel.cc/#cygiYmQgc2QiKS5vc2MoKQ%3D%3D)

...ou testez-le ici :

<MiniRepl client:only="react" tune={`s("bd sd").osc()`} />

Si vous entendez maintenant du son, félicitations ! Sinon, vous pouvez obtenir de l'aide sur le [canal #strudel dans le discord TidalCycles](https://discord.com/invite/HGEdXmRkzT).

Remarque : si vous avez la 'Cible du moteur audio' dans les paramètres définie sur 'OSC', vous n'avez pas besoin d'ajouter .osc() à la fin de votre pattern.

### Pattern.osc

<JsDoc client:idle name="Pattern.osc" h={0} />

## Paramètres SuperDirt

Veuillez vous référer à [Tidal Docs](https://tidalcycles.org/) pour plus d'informations.

<br />

Mais pouvons-nous utiliser Strudel [hors ligne](/learn/pwa) ?

# MQTT

MQTT est un protocole réseau léger, conçu pour les périphériques 'internet des objets'. Pour une utilisation avec Strudel, vous aurez
besoin d'un accès à un serveur MQTT appelé 'broker' configuré pour accepter des connexions 'websocket' sécurisées. Vous pourriez
en exécuter un vous-même (par exemple en exécutant [mosquitto](https://mosquitto.org/)), bien qu'obtenir un certificat SSL que
votre navigateur web fera confiance pourrait être un peu délicat pour ceux sans expérience en administration système.
Alternativement, vous pouvez utiliser [un broker public](https://www.hivemq.com/mqtt/public-mqtt-broker/).

Strudel ne prend pas encore en charge la réception de messages via MQTT, seulement leur envoi.

## Utilisation

L'exemple suivant montre comment envoyer un pattern à un broker MQTT :

<MiniRepl
  client:only="react"
  tune={`"hello world"
    .mqtt(undefined, // nom d'utilisateur (undefined pour serveurs ouverts/publics)
          undefined, // mot de passe
          '/strudel-pattern', // 'topic' mqtt
          'wss://mqtt.eclipseprojects.io:443/mqtt', // adresse serveur MQTT
          'mystrudel', // id client MQTT - généré aléatoirement si non fourni
          0 // latence / délai avant l'envoi de messages (0 = pas de délai)
         )`}

/>

D'autres logiciels peuvent alors recevoir les messages. Par exemple en utilisant les outils client en ligne de commande [mosquitto](https://mosquitto.org/) :

```

> mosquitto_sub -h mqtt.eclipseprojects.io -p 1883 -t "/strudel-pattern"
> hello
> world
> hello
> world
> ...

```

Les patterns de contrôle seront encodés en JSON, par exemple :

<MiniRepl
  client:only="react"
  tune={`sound("sax(3,8)").speed("2 3")
  .mqtt(undefined, // nom d'utilisateur (undefined pour serveurs ouverts/publics)
        undefined, // mot de passe
        '/strudel-pattern', // 'topic' mqtt
        'wss://mqtt.eclipseprojects.io:443/mqtt', // adresse serveur MQTT
        'mystrudel', // id client MQTT - généré aléatoirement si non fourni
        0 // latence / délai avant l'envoi de messages (0 = pas de délai)
       )`}
/>

Enverra des messages comme les suivants :

```

{"s":"sax","speed":2}
{"s":"sax","speed":2}
{"s":"sax","speed":3}
{"s":"sax","speed":2}
...

```

Des bibliothèques pour recevoir MQTT sont disponibles pour de nombreux langages de programmation.

```
