---
title: REPL
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';

# REPL

{/* Le [REPL](https://strudel.cc/) est l'endroit où tous les packages se rejoignent pour former un système de live coding. Il peut également être vu comme une implémentation de référence pour les utilisateurs de la bibliothèque. */}

Bien que Strudel puisse être utilisé comme une bibliothèque dans n'importe quelle base de code JavaScript, son interface utilisateur principale de référence est le Strudel REPL[^1], qui est un environnement de live coding basé sur le navigateur. Cet éditeur de live code est dédié à la manipulation des patterns Strudel pendant qu'ils jouent. Le REPL propose un retour visuel intégré, mettant en évidence quels éléments dans les séquences rythmées (mini-notation) influencent l'événement qui est actuellement joué. Ce retour est conçu pour soutenir à la fois l'apprentissage et l'utilisation en direct de Strudel.

[^1]: REPL signifie read, evaluate, print/play, loop (lire, évaluer, imprimer/jouer, boucler). C'est un jargon amical pour une interface de programmation interactive issue de l'héritage informatique, généralement pour une interface en ligne de commande mais aussi appliqué aux éditeurs de live coding.

Outre une UI pour le contrôle de la lecture et les méta-informations, la partie principale de l'interface du REPL est l'éditeur de code propulsé par CodeMirror. Dans celui-ci, l'utilisateur peut éditer et évaluer le code de pattern en direct, en utilisant l'une des sorties de synthèse disponibles pour créer de la musique et/ou de l'art sonore. Le flux de contrôle du REPL suit 3 étapes de base :

1. L'utilisateur écrit et met à jour le code. Chaque mise à jour le transpile et l'évalue pour créer une instance de `Pattern`
2. Pendant que le REPL fonctionne, le `Scheduler` requête le `Pattern` actif à intervalles réguliers, générant des `Events` (aussi connus sous le nom de `Haps` dans Strudel) pour la période de temps suivante.
3. Pour chaque tick de planification, tous les `Events` générés sont déclenchés en appelant leur méthode `onTrigger`, qui est définie par la sortie.

<img src="https://codeberg.org/uzu/strudel/raw/branch/talk/talk/public/strudelflow.png" width="600" />

## Code Utilisateur

Pour créer un `Pattern` à partir du code utilisateur, deux étapes sont nécessaires :

1. Transpiler le code JS d'entrée pour le rendre fonctionnel
2. Évaluer le code transpilé

### Transpilation & Évaluation

Dans le monde JavaScript, l'utilisation de la transpilation est une pratique courante pour pouvoir utiliser des fonctionnalités de langage qui ne sont pas supportées par le langage de base. Des outils comme `babel` transpileront le code qui contient des fonctionnalités de langage non supportées en une version du code sans ces fonctionnalités.

Dans la même tradition, Strudel peut ajouter une étape de transpilation pour simplifier le code utilisateur dans le contexte du live coding. Par exemple, le REPL Strudel permet à l'utilisateur de créer des patterns de mini-notation en utilisant juste des chaînes entre guillemets doubles, tandis que les chaînes entre guillemets simples restent ce qu'elles sont :

```strudel
note("c3 [e3 g3]*2")
```

est transpilé en :

```strudel
note(m('c3 [e3 g3]', 5))
```

Ici, la chaîne est enveloppée dans `m`, qui créera un pattern à partir d'une chaîne de mini-notation. Comme deuxième paramètre, elle reçoit l'emplacement du code source de la chaîne, ce qui permet de mettre en évidence les événements actifs plus tard.

Après la transpilation, le code est prêt à être évalué en un `Pattern`.

En coulisses, la chaîne de code utilisateur est analysée avec `acorn`, la transformant en un Arbre de Syntaxe Abstraite (AST). L'AST permet de changer la structure du code avant de générer la version transpilée en utilisant `escodegen`.

### Mini-notation

Bien que la transpilation permette à JavaScript d'exprimer des Patterns de manière moins verbeuse, il est toujours préférable d'utiliser la mini-notation comme une façon plus compacte d'exprimer le rythme. Strudel vise à fournir les mêmes fonctionnalités et syntaxe de mini-notation que celles utilisées dans Tidal.

Le parseur de mini-notation est implémenté en utilisant `peggy`, qui permet de générer des parseurs performants pour les Langages Spécifiques au Domaine (DSL) en utilisant une notation de grammaire concise. Le parseur généré transforme la chaîne de mini-notation en un AST qui est utilisé pour appeler les fonctions Strudel respectives avec la structure donnée. Par exemple, `"c3 [e3 g3]*2"` résultera en les appels suivants :

```strudel
seq(
  reify('c3').withLoc(6, 9),
  seq(reify('e3').withLoc(10, 12), reify('g3',).withLoc(13, 15))
)
```

### Mise en Évidence des Emplacements

Comme vu dans les exemples ci-dessus, le parseur de mini-notation ajoute les emplacements du code source en utilisant `withLoc`.
Cet emplacement est calculé dans la fonction `m`, comme la somme de 2 emplacements :

1. l'emplacement où la chaîne de mini notation commence, tel qu'obtenu du parseur JS
2. l'emplacement de la sous-chaîne à l'intérieur de la mini notation, tel qu'obtenu du parseur de mini notation

La somme des deux est passée à `withLoc` pour dire à chaque élément son emplacement, qui peut être utilisé plus tard pour la mise en évidence quand il est actif.

### Mini Notation

Une autre partie importante du code utilisateur est la mini notation, qui permet d'exprimer des rythmes de manière courte.

- la mini notation est [implémentée comme une grammaire PEG](https://codeberg.org/uzu/strudel/src/branch/talk/packages/mini/krill.pegjs), vivant dans le [package mini](https://codeberg.org/uzu/strudel/src/branch/main/packages/mini)
- elle est basée sur [krill](https://github.com/Mdashdotdashn/krill) par Mdashdotdashn
- la grammaire peg est utilisée pour générer un parseur avec [peggyjs](https://peggyjs.org/)
- le parseur généré prend une chaîne de mini notation et produit un AST
- l'AST peut ensuite être utilisé pour construire un pattern en utilisant l'API Strudel régulière

Voici un exemple d'AST pour `c3 [e3 g3]`

```json
{
  "type_": "pattern",
  "arguments_": { "alignment": "h" },
  "source_": [
    {
      "type_": "element", "source_": "c3",
      "location_": { "start": { "offset": 1, "line": 1, "column": 2 }, "end": { "offset": 4, "line": 1, "column": 5 } }
    },
    {
      "type_": "element",
      "location_": { "start": { "offset": 4, "line": 1, "column": 5 }, "end": { "offset": 11, "line": 1, "column": 12 } }
      "source_": {
        "type_": "pattern", "arguments_": { "alignment": "h" },
        "source_": [
          {
            "type_": "element", "source_": "e3",
            "location_": { "start": { "offset": 5, "line": 1, "column": 6 }, "end": { "offset": 8, "line": 1, "column": 9 } }
          },
          {
            "type_": "element", "source_": "g3",
            "location_": { "start": { "offset": 8, "line": 1, "column": 9 }, "end": { "offset": 10, "line": 1, "column": 11 } }
          }
        ]
      },
    }
  ]
}
```

qui se traduit en `seq(c3, seq(e3, g3))`

## Planification des Événements

Après qu'une instance de `Pattern` est obtenue à partir du code utilisateur,
elle est utilisée par le planificateur pour être requêtée pour des événements. Une fois démarré, le planificateur fonctionne à intervalle fixe pour requêter le pattern actif pour des événements dans la période de temps de l'intervalle actuel. Une implémentation simplifiée ressemble à ceci :

```js
let pattern = seq('c3', ['e3', 'g3']); // pattern de l'utilisateur
let interval = 0.5; // intervalle de requête en secondes
let time = 0; // début de la période de temps actuelle
let minLatency = 0.1; // temps min avant qu'un hap devrait se déclencher
setInterval(() => {
  const haps = pattern.queryArc(time, time + interval);
  time += interval; // incrémenter le temps
  haps.forEach((hap) => {
    const deadline = hap.whole.begin - time + minLatency;
    onTrigger(hap, deadline, duration);
  });
}, interval * 1000); // requêter chaque "interval" secondes
```

Notez que le code ci-dessus est simplifié à des fins illustratives. L'implémentation réelle doit contourner les callbacks imprécis de `setInterval`. Plus de détails sur l'implémentation peuvent être lus dans [cet article de blog](https://loophole-letters.vercel.app/web-audio-scheduling).

Le fait que `Pattern.queryArc` soit une fonction pure qui mappe une période de temps à un ensemble d'événements nous permet de choisir n'importe quel intervalle que nous aimons sans changer la sortie résultante. Cela signifie également que lorsque le pattern est changé de l'extérieur, le prochain callback de planification fonctionnera avec le nouveau pattern, gardant son horloge en marche.

La latence entre le moment où le pattern est évalué et le changement est entendu est entre `minLatency` et `interval + minLatency`, dans notre exemple entre 100ms et 600ms. Dans Strudel, l'intervalle de requête actuel est de 50ms avec une minLatency de 100ms, ce qui signifie que la latence est entre 50ms et 150ms.

## Sortie

La dernière étape est de déclencher chaque événement dans la sortie choisie.
C'est là que le temps et la valeur donnés de chaque événement sont utilisés pour générer de l'audio ou toute autre forme de sortie basée sur le temps. La sortie par défaut du REPL Strudel est la sortie WebAudio. Pour comprendre ce que fait une sortie, nous devons d'abord comprendre ce que sont les paramètres de contrôle.

### Paramètres de Contrôle

Pour pouvoir manipuler plusieurs aspects du son en parallèle, des paramètres de contrôle sont utilisés pour façonner la valeur de chaque événement. Exemple :

```js
note('c3 e3')
  .cutoff(1000)
  .s('sawtooth')
  .queryArc(0, 1)
  .map((hap) => hap.value);
/* [
  { note: 'c3', cutoff: 1000, s: 'sawtooth' }
  { note: 'e3', cutoff: 1000, s: 'sawtooth' }
] */
```

Ici, les fonctions de paramètres de contrôle `note`, `cutoff` et `s` sont utilisées, où chacune contrôle une propriété différente dans l'objet de valeur. Chaque fonction de paramètre de contrôle accepte une valeur primitive, une liste de valeurs à séquencer en un `Pattern`, ou un `Pattern`. Dans l'exemple, `note` obtient un `Pattern` d'une expression de mini-notation (guillemets doubles), tandis que `cutoff` et `s` reçoivent respectivement un `Number` et une `String` (guillemets simples).

Strudel vient avec un grand ensemble par défaut de fonctions de paramètres de contrôle qui sont basées sur celles utilisées par Tidal et SuperDirt, se concentrant sur la terminologie musicale et audio. Il est cependant possible de créer des paramètres de contrôle personnalisés pour n'importe quel but :

```js
const { x, y } = createParams('x', 'y');
x(sine.range(0, 200)).y(cosine.range(0, 200));
```

Cet exemple crée les paramètres de contrôle personnalisés `x` et `y` qui sont ensuite utilisés pour former un pattern qui décrit les coordonnées d'un cercle.

### Sorties

Maintenant que nous savons comment la valeur d'un événement est manipulée en utilisant des paramètres de contrôle, nous pouvons regarder comment les sorties peuvent utiliser cette valeur pour générer n'importe quoi. Le planificateur ci-dessus appelait la fonction `onTrigger` qui est utilisée pour implémenter la sortie. Une version très simple de la sortie web audio pourrait ressembler à ceci :

```js
function onTrigger(hap, deadline, duration) {
  const { note } = hap.value;
  const time = getAudioContext().currentTime + deadline;
  const o = getAudioContext().createOscillator();
  o.frequency.value = getFreq(note);
  o.start(time);
  o.stop(time + event.duration);
  o.connect(getAudioContext().destination);
}
```

L'exemple ci-dessus créera un `OscillatorNode` pour chaque événement, où la fréquence est contrôlée par le paramètre `note`. En essence, c'est ainsi que fonctionne la sortie de l'API WebAudio de Strudel, seulement avec beaucoup plus de paramètres pour contrôler les synthés, samples et effets.

Je veux aider, comment puis-je contribuer à la [Documentation](/technical-manual/docs) ?
