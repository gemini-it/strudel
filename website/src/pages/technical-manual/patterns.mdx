---
title: Patterns
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Patterns

Les patterns sont l'essence de Tidal. Ses patterns sont des entités abstraites qui représentent des flux de temps sous forme de fonctions, adaptant une technique appelée programmation fonctionnelle réactive pure. En prenant une période de temps en entrée, un Pattern peut produire un ensemble d'événements qui se produisent dans cette période de temps. La manière dont les événements sont situés dans le temps dépend de la structure du Pattern.
Désormais, ce processus de génération d'événements à partir d'une période de temps sera appelé **requête**.
Exemple :

<MiniRepl
  client:idle
  tune={`const pattern = sequence("c3", ["e3", "g3"])
const events = pattern.queryArc(0, 1)
console.log(events.map((e) => e.show()))
silence`}
/>

Dans cet exemple, nous créons un pattern en utilisant la fonction `sequence` et le **requêtons** pour la période de temps de `0` à `1`.
Ces nombres représentent des unités de temps appelées **cycles**. La longueur d'un cycle dépend du tempo, qui par défaut est d'un cycle par seconde.
Les événements résultants sont :

```js
[
  '[ 0/1 -> 1/2 | c3 ]', //
  '[ 1/2 -> 3/4 | e3 ]',
  '[ 3/4 -> 1/1 | g3 ]',
];
```

Chaque événement a une valeur, une heure de début et une heure de fin, où le temps est représenté sous forme de fraction. Dans le cas ci-dessus, les événements sont placés dans un ordre séquentiel, où c3 prend la première moitié, et e3 et g3 ensemble prennent la seconde moitié. Ce placement temporel est le résultat de la fonction `sequence`, qui divise ses arguments de manière égale sur un cycle. Si un argument est un tableau, la même règle s'applique à cette partie du cycle. Dans l'exemple, e3 et g3 sont divisés de manière égale sur la seconde moitié du cycle entier.

Notez que la fonction de requête n'est pas seulement un moyen d'accéder à un pattern, mais fidèle aux principes de la programmation fonctionnelle, est le pattern lui-même. Cela signifie qu'en théorie, il n'y a aucun moyen de changer un pattern, il est opaque comme une fonction pure. En pratique cependant, Strudel et Tidal consistent à transformer des patterns, alors comment cela se fait-il ? La réponse est, en remplaçant le pattern par un nouveau, qui appelle l'ancien. Ce nouveau n'est capable que de manipuler la requête avant de la passer à l'ancien pattern, et de manipuler les résultats de celui-ci avant de les renvoyer à l'appelant. Mais cela suffit pour prendre en charge toutes les manipulations temporelles et structurelles fournies par la vaste bibliothèque de fonctions de Strudel (et Tidal).

Les exemples ci-dessus ne représentent pas la façon dont Strudel est utilisé en pratique. Dans l'éditeur de live coding, l'utilisateur doit seulement taper le pattern lui-même, la requête sera gérée par le planificateur. Le planificateur requêtera à plusieurs reprises le pattern pour les événements, qui sont ensuite planifiés comme synthèse sonore ou autres déclencheurs d'événements.

Pouvons-nous [aligner](/technical-manual/alignment) les patterns ?
