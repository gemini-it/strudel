---
title: Premiers Effets
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import QA from '@components/QA';

# Premiers Effets

import Box from '@components/Box.astro';

Nous avons des sons, nous avons des notes, maintenant voyons les effets !

## Quelques effets de base

**Filtre passe-bas**

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>")
.sound("sawtooth").lpf(800)`}
/>

<Box>

lpf = **f**iltre **p**asse-**b**as (**l**ow **p**ass **f**ilter)

- Changez lpf √† 200. Remarquez comme cela devient √©touff√©. Pensez-y comme si vous √©tiez devant le club avec la porte ferm√©e üö™.
- Maintenant, ouvrons la porte... changez-le √† 5000. Remarquez comme cela devient plus brillant ‚ú®ü™©

</Box>

**Patteriser le filtre**

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>")
.sound("sawtooth").lpf("200 1000 200 1000")`}
/>

<Box>

- Essayez d'ajouter plus de valeurs
- Remarquez comment le motif dans lpf ne change pas le rythme global

Nous apprendrons comment automatiser avec des ondes plus tard...

</Box>

**vowel (voyelle)**

<MiniRepl
  client:visible
  tune={`note("<[c3,g3,e4] [bb2,f3,d4] [a2,f3,c4] [bb2,g3,eb4]>")
.sound("sawtooth").vowel("<a e i o>")`}
/>

**gain (volume)**

<MiniRepl
  client:visible
  tune={`$: sound("hh*16").gain("[.25 1]*4")

$: sound("bd*4,[~ sd:1]*2")`}
punchcard
/>

<Box>

Le rythme est une question de dynamique !

- Supprimez `.gain(...)` et remarquez comme le son devient plat.
- Ramenez-le en annulant (Ctrl+z)

</Box>

Combinons tout ce qui pr√©c√®de dans un petit morceau :

<MiniRepl
  client:visible
  tune={`$: sound("hh*16").gain("[.25 1]*4")

$: sound("bd*4,[~ sd:1]*2")

$: note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>")
.sound("sawtooth").lpf("200 1000 200 1000")

$: note("<[c3,g3,e4] [bb2,f3,d4] [a2,f3,c4] [bb2,g3,eb4]>")
.sound("sawtooth").vowel("<a e i o>")`}
/>

**Fa√ßonner le son avec une enveloppe ADSR**

<MiniRepl
  client:visible
  tune={`note("c3 bb2 f3 eb3")
.sound("sawtooth").lpf(600)
.attack(.1)
.decay(.1)
.sustain(.25)
.release(.2)`}
/>

<Box>

Essayez de d√©couvrir ce que font les nombres. Comparez les √©l√©ments suivants :

- attack (attaque) : `.5` vs `0`
- decay (d√©croissance) : `.5` vs `0`
- sustain (maintien) : `1` vs `.25` vs `0`
- release (rel√¢chement) : `0` vs `.5` vs `1`

Pouvez-vous deviner ce qu'ils font ?

</Box>

<QA q="Cliquez pour voir la solution" client:visible>

- attack : temps n√©cessaire pour le fondu d'entr√©e
- decay : temps n√©cessaire pour atteindre le niveau de sustain
- sustain : niveau apr√®s decay
- release : temps n√©cessaire pour le fondu de sortie apr√®s la fin de la note

![ADSR](https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/ADSR_parameter.svg/1920px-ADSR_parameter.svg.png)

</QA>

**notation courte adsr**

<MiniRepl
  client:visible
  tune={`note("c3 bb2 f3 eb3")
.sound("sawtooth").lpf(600)
.adsr(".1:.1:.5:.2")
`}
/>

**delay (d√©lai)**

<MiniRepl
  client:visible
  tune={`$: note("[~ [<[d3,a3,f4]!2 [d3,bb3,g4]!2> ~]]*2")
  .sound("gm_electric_guitar_muted").delay(.5)

$: sound("bd rim").bank("RolandTR707").delay(".5")`}
/>

<Box>

Essayez quelques valeurs de `delay` entre 0 et 1. D'ailleurs, `.5` est l'abr√©viation de `0.5`

Que se passe-t-il si vous utilisez `.delay(".8:.125")` ? Pouvez-vous deviner ce que fait le deuxi√®me nombre ?

Que se passe-t-il si vous utilisez `.delay(".8:.06:.8")` ? Pouvez-vous deviner ce que fait le troisi√®me nombre ?

</Box>

<QA q="Cliquez pour voir la solution" client:visible>

`delay("a:b:c")` :

- a : volume du d√©lai
- b : temps du d√©lai
- c : feedback (nombre plus petit = fondu plus rapide)

</QA>

**room alias reverb (r√©verb√©ration)**

<MiniRepl
  client:visible
  tune={`n("<4 [3@3 4] [<2 0> ~@16] ~>")
.scale("D4:minor").sound("gm_accordion:2")
.room(2)`}
/>

<Box>

Essayez diff√©rentes valeurs !

Ajoutez aussi un d√©lai !

</Box>

**Petit morceau de dub**

<MiniRepl
  client:visible
  tune={`$: note("[~ [<[d3,a3,f4]!2 [d3,bb3,g4]!2> ~]]*2")
.sound("gm_electric_guitar_muted").delay(.5)

$: sound("bd rim").bank("RolandTR707").delay(.5)

$: n("<4 [3@3 4] [<2 0> ~@16] ~>")
.scale("D4:minor").sound("gm_accordion:2")
.room(2).gain(.5)`}
/>

Ajoutons une basse pour compl√©ter cela :

<MiniRepl
  client:visible
  tune={`$: note("[~ [<[d3,a3,f4]!2 [d3,bb3,g4]!2> ~]]*2")
.sound("gm_electric_guitar_muted").delay(.5)

$: sound("bd rim").bank("RolandTR707").delay(.5)

$: n("<4 [3@3 4] [<2 0> ~@16] ~>")
.scale("D4:minor").sound("gm_accordion:2")
.room(2).gain(.4)

$: n("[0 [~ 0] 4 [3 2] [0 ~] [0 ~] <0 2> ~]/2")
.scale("D2:minor")
.sound("sawtooth,triangle").lpf(800)`}
/>

<Box>

Essayez d'ajouter `.hush()` √† la fin d'un des motifs dans la pile...

</Box>

**pan (panoramique)**

<MiniRepl
  client:visible
  tune={`sound("numbers:1 numbers:2 numbers:3 numbers:4")
  .pan("0 0.3 .6 1")`}
/>

**speed (vitesse)**

<MiniRepl client:visible tune={`sound("bd rim [~ bd] rim").speed("<1 2 -1 -2>").room(.2)`} />

**fast et slow**

Nous pouvons utiliser `fast` et `slow` pour changer le tempo d'un motif en dehors de la mini-notation :

<MiniRepl client:visible tune={`sound("bd*4,~ rim ~ cp").slow(2)`} />

<Box>

Changez la valeur de `slow`. Essayez de la remplacer par `fast`.

Que se passe-t-il si vous utilisez un motif comme `.fast("<1 [2 4]>")` ?

</Box>

D'ailleurs, dans la mini-notation, `fast` correspond √† `*` et `slow` correspond √† `/`.

<MiniRepl client:visible tune={`sound("[bd*4,~ rim ~ cp]*<1 [2 4]>")`} />

## Modulation avec des signaux

Au lieu de changer les valeurs par paliers, nous pouvons √©galement les contr√¥ler avec des signaux :

<MiniRepl client:visible tune={`sound("hh*16").gain(sine)`} punchcard punchcardLabels={false} />

<Box>

Les formes d'onde de base pour les signaux sont `sine`, `saw`, `square`, `tri` üåä

Essayez aussi les signaux al√©atoires `rand` et `perlin` !

Le gain est visualis√© comme la transparence dans le pianoroll.

</Box>

**D√©finir une plage**

Par d√©faut, les ondes oscillent entre 0 et 1. Nous pouvons changer cela avec `range` :

<MiniRepl client:visible tune={`sound("hh*16").lpf(saw.range(500, 2000))`} />

<Box>

Que se passe-t-il si vous inversez les valeurs de plage ?

</Box>

Nous pouvons changer la vitesse de modulation avec slow / fast :

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>")
  .sound("sawtooth")
  .lpf(sine.range(100, 2000).slow(4))`}
/>

<Box>

La modulation compl√®te prendra maintenant 8 cycles pour se r√©p√©ter.

</Box>

## R√©capitulatif

| nom     | exemple                                                                                                          |
| ------- | ---------------------------------------------------------------------------------------------------------------- |
| lpf     | <MiniRepl client:visible tune={`note("c2 c3 c2 c3").s("sawtooth").lpf("<400 2000>")`} />                         |
| vowel   | <MiniRepl client:visible tune={`note("c3 eb3 g3").s("sawtooth").vowel("<a e i o>")`} />                          |
| gain    | <MiniRepl client:visible tune={`s("hh*16").gain("[.25 1]*2")`} />                                                |
| delay   | <MiniRepl client:visible tune={`s("bd rim bd cp").delay(.5)`} />                                                 |
| room    | <MiniRepl client:visible tune={`s("bd rim bd cp").room(.5)`} />                                                  |
| pan     | <MiniRepl client:visible tune={`s("bd rim bd cp").pan("0 1")`} />                                                |
| speed   | <MiniRepl client:visible tune={`s("bd rim bd cp").speed("<1 2 -1 -2>")`} />                                      |
| signals | `sine`, `saw`, `square`, `tri`, `rand`, `perlin`<br/><MiniRepl client:visible tune={`s("hh*16").gain  (saw)`} /> |
| range   | <MiniRepl client:visible tune={`s("hh*16").lpf(saw.range(200,4000))`} />                                         |

Jetons maintenant un coup d'≈ìil √† certains [effets de motif](/workshop/pattern-effects) typiques de Tidal.