---
title: Premiers Effets
layout: ../../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../../docs/MiniRepl';
import QA from '@components/QA';

# Premiers Effets

import Box from '@components/Box.astro';

## Quelques effets fondamentaux

**lpf**

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>/2")
.sound("sawtooth").lpf(800)`}
/>

<Box>

lpf = **f**iltre **p**asse-**b**as

- Change `lpf` en 200. Entends-tu comme la basse sonne plus √©touff√©e ? On dirait que la musique joue derri√®re une porte ferm√©e üö™.
- Maintenant, ouvrons la porte : change `lpf` en 5000. Le son devient beaucoup plus lumineux et plus net ‚ú®ü™©.

</Box>

**Automatiser le filtre**

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>/2")
.sound("sawtooth").lpf("200 1000")`}
/>

<Box>

- Ajoute encore plus de valeurs `lpf`.
- Le motif dans `lpf` ne change pas le rythme de la ligne de basse.

Plus tard, nous verrons comment automatiser des choses avec des formes d'onde.

</Box>

**vowel (voyelle)**

<MiniRepl
  client:visible
  tune={`note("<[c3,g3,e4] [bb2,f3,d4] [a2,f3,c4] [bb2,g3,eb4]>/2")
.sound("sawtooth").vowel("<a e i o>/2")`}
/>

**gain (gain)**

<MiniRepl
  client:visible
  tune={`stack(
  sound("hh*8").gain("[.25 1]*2"),
  sound("bd*2,~ sd:1")
) `}
  punchcard
/>

<Box>

Dans les rythmes, la dynamique (= changements de volume) est tr√®s importante.

- Supprime `.gain(...)` et observe √† quel point le son est beaucoup plus plat.
- Annule (Ctrl+z puis Ctrl+Entr√©e).

</Box>

**Stacks dans les stacks**

Combinons les exemples ci-dessus :

<MiniRepl
  client:visible
  tune={`stack(
  stack(
    sound("hh*8").gain("[.25 1]*2"),
    sound("bd*2,~ sd:1")
  ),
  note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>/2")
  .sound("sawtooth").lpf("200 1000"),
  note("<[c3,g3,e4] [bb2,f3,d4] [a2,f3,c4] [bb2,g3,eb4]>/2")
  .sound("sawtooth").vowel("<a e i o>/2")
) `}
/>

<Box>

Essaie d'identifier les parties individuelles √† l'int√©rieur de `stack`. Regarde comment les virgules sont plac√©es.

Les 3 parties (batterie, basse, accords) sont exactement comme avant, juste dans un `stack`, s√©par√©es par des virgules.

</Box>

**Fa√ßonner le son avec l'enveloppe ADSR**

<MiniRepl
  client:visible
  tune={`note("<c3 bb2 f3 eb3>")
.sound("sawtooth").lpf(600)
.attack(.1)
.decay(.1)
.sustain(.25)
.release(.2)`}
/>

<Box>

Essaie de comprendre ce que font les chiffres. Essaie ce qui suit :

- attack: `.5` vs `0`
- decay: `.5` vs `0`
- sustain: `1` vs `.25` vs `0`
- release: `0` vs `.5` vs `1`

Peux-tu deviner ce que fait chaque valeur ?

</Box>

<QA q="Afficher la solution" client:visible>

- attack (attaque) : Temps de mont√©e
- decay (d√©clin) : Temps de descente
- sustain (maintien) : Volume apr√®s le d√©clin
- release (rel√¢chement) : Temps de descente apr√®s la fin

![ADSR](https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/ADSR_parameter.svg/1920px-ADSR_parameter.svg.png)

</QA>

**Notation abr√©g√©e ADSR**

<MiniRepl
  client:visible
  tune={`note("<c3 bb2 f3 eb3>")
.sound("sawtooth").lpf(600)
.adsr(".1:.1:.5:.2")
`}
/>

**delay (d√©lai)**

<MiniRepl
  client:visible
  tune={`stack(
  note("~ [<[d3,a3,f4]!2 [d3,bb3,g4]!2> ~]")
  .sound("gm_electric_guitar_muted"),
  sound("<bd rim>").bank("RolandTR707")
).delay(".5")`}
/>

<Box>

Essaie diff√©rentes valeurs de `delay` entre 0 et 1. D'ailleurs : `.5` est l'abr√©viation de `0.5`.

Que se passe-t-il si tu √©cris `.delay(".8:.125")` ? Peux-tu deviner ce que fait le deuxi√®me chiffre ?

Que se passe-t-il si tu √©cris `.delay(".8:.06:.8")` ? Peux-tu deviner ce que fait le troisi√®me chiffre ?

</Box>

<QA q="Afficher la solution" client:visible>

`delay("a:b:c")` :

- a : Volume du d√©lai
- b : Temps de retard
- c : Feedback (plus le chiffre est petit, plus le d√©lai dispara√Æt vite)

</QA>

**room alias reverb (r√©verb√©ration)**

<MiniRepl
  client:visible
  tune={`n("<4 [3@3 4] [<2 0> ~@16] ~>/2")
.scale("D4:minor").sound("gm_accordion:2")
.room(2)`}
/>

<Box>

Joue avec diff√©rentes valeurs.

Ajoute aussi un d√©lai !

</Box>

**Petit morceau de dub**

<MiniRepl
  client:visible
  tune={`stack(
  note("~ [<[d3,a3,f4]!2 [d3,bb3,g4]!2> ~]")
  .sound("gm_electric_guitar_muted").delay(.5),
  sound("<bd rim>").bank("RolandTR707").delay(.5),
  n("<4 [3@3 4] [<2 0> ~@16] ~>/2")
  .scale("D4:minor").sound("gm_accordion:2")
  .room(2).gain(.5)
)`}
/>

Pour du vrai dub, il manque encore la basse :

<MiniRepl
  client:visible
  tune={`stack(
  note("~ [<[d3,a3,f4]!2 [d3,bb3,g4]!2> ~]")
  .sound("gm_electric_guitar_muted").delay(.5),
  sound("<bd rim>").bank("RolandTR707").delay(.5),
  n("<4 [3@3 4] [<2 0> ~@16] ~>/2")
  .scale("D4:minor").sound("gm_accordion:2")
  .room(2).gain(.4),
  n("<0 [~ 0] 4 [3 2] [0 ~] [0 ~] <0 2> ~>*2")
  .scale("D2:minor")
  .sound("sawtooth,triangle").lpf(800)
)`}
/>

<Box>

Ajoute `.hush()` √† la fin d'un motif dans le stack...

</Box>

**pan (panoramique)**

<MiniRepl
  client:visible
  tune={`sound("numbers:1 numbers:2 numbers:3 numbers:4")
.pan("0 0.3 .6 1")
.slow(2)`}
/>

**speed (vitesse)**

<MiniRepl client:visible tune={`sound("bd rim").speed("<1 2 -1 -2>").room(.2)`} />

**fast and slow (rapide et lent)**

Avec `fast` et `slow`, on peut changer le tempo d'un motif en dehors de la mini-notation :

<MiniRepl client:visible tune={`sound("bd*2,~ rim").slow(2)`} />

<Box>

Modifie la valeur de `slow`. Remplace `slow` par `fast`.

Que se passe-t-il si tu automatises la valeur ? Par exemple `.fast("<1 [2 4]>")` ?

</Box>

D'ailleurs, dans la mini-notation : `fast` est `*` et `slow` est `/`.

<MiniRepl client:visible tune={`sound("[bd*2,~ rim]*<1 [2 4]>")`} />

## Automatisation avec les signaux

Au lieu d'automatiser des valeurs pas √† pas, nous pouvons √©galement utiliser des signaux :

<MiniRepl client:visible tune={`sound("hh*16").gain(sine)`} punchcard punchcardLabels={false} />

<Box>

Les formes d'onde de base sont `sine`, `saw`, `square`, `tri` üåä.

Essaie aussi les signaux al√©atoires `rand` et `perlin` !

La valeur `gain` (amplification) est repr√©sent√©e dans la visualisation comme une transparence.

</Box>

**Changer la plage avec `range`**

Les signaux ont une plage de 0 √† 1 par d√©faut. Nous pouvons changer cela avec `range` :

<MiniRepl client:visible tune={`sound("hh*8").lpf(saw.range(500, 2000))`} />

`range` est utile lorsque nous voulons automatiser des fonctions avec une plage de valeurs diff√©rente de 0 et 1 (par exemple `lpf`).

<Box>

Que se passe-t-il si tu inverses les deux valeurs ?

</Box>

Nous pouvons changer la vitesse de l'automatisation avec slow / fast :

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>/2")
.sound("sawtooth")
.lpf(sine.range(100, 2000).slow(8))`}
/>

<Box>

L'automatisation enti√®re prend maintenant 8 cycles jusqu'√† ce qu'elle se r√©p√®te.

</Box>

## R√©sum√©

| Name  | Beispiel                                                                                |
| ----- | --------------------------------------------------------------------------------------- |
| lpf   | <MiniRepl client:visible tune={`note("c2 c3").s("sawtooth").lpf("<400 2000>")`} />      |
| vowel | <MiniRepl client:visible tune={`note("c3 eb3 g3").s("sawtooth").vowel("<a e i o>")`} /> |
| gain  | <MiniRepl client:visible tune={`s("hh*8").gain("[.25 1]*2")`} />                        |
| delay | <MiniRepl client:visible tune={`s("bd rim").delay(.5)`} />                              |
| room  | <MiniRepl client:visible tune={`s("bd rim").room(.5)`} />                               |
| pan   | <MiniRepl client:visible tune={`s("bd rim").pan("0 1")`} />                             |
| speed | <MiniRepl client:visible tune={`s("bd rim").speed("<1 2 -1 -2>")`} />                   |
| range | <MiniRepl client:visible tune={`s("hh*16").lpf(saw.range(200,4000))`} />                |

Regardons maintenant les [effets de motif](/de/workshop/pattern-effects) typiques de Tidal.
