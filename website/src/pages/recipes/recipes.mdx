---
title: Recettes
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';

# Recettes

Cette page présente différentes façons d'atteindre des objectifs musicaux courants (ou moins courants).
Il existe souvent plusieurs façons de faire une chose et il n'y a pas de bonne ou de mauvaise réponse.
La partie amusante est que chaque représentation vous donnera différentes impulsions lors de l'improvisation.

## Arpèges

Un arpège est lorsque les notes d'un accord sont jouées en séquence.
Nous pouvons soit écrire les notes à la main :

<MiniRepl
  client:visible
  tune={`note("c eb g c4")
.clip(2).s("gm_electric_guitar_clean")`}
  punchcard
/>

...ou utiliser des gammes :

<MiniRepl
  client:visible
  tune={`n("0 2 4 7").scale("C:minor")
.clip(2).s("gm_electric_guitar_clean")`}
  punchcard
/>

...ou des symboles d'accords :

<MiniRepl
  client:visible
  tune={`n("0 1 2 3").chord("Cm").mode("above:c3").voicing()
.clip(2).s("gm_electric_guitar_clean")`}
  punchcard
/>

...en utilisant off :

<MiniRepl
  client:visible
  tune={`"0"
  .off(1/3, add(2))
  .off(1/2, add(4))
  .n()
  .scale("C:minor")
  .s("gm_electric_guitar_clean")`}
  punchcard
/>

## Découper des Breaks

Un sample peut être bouclé et découpé comme ceci :

<MiniRepl
  client:visible
  tune={`samples('github:yaxu/clean-breaks')
s("amen/4").fit().chop(32)`}
  punchcard
/>

Cela adapte le break sur 8 cycles + le découpe en 16 morceaux.
Les découpes ne sont pas encore audibles, car nous ne faisons aucune manipulation.
Ajoutons un doublage et une inversion aléatoires :

<MiniRepl
  client:visible
  tune={`samples('github:yaxu/clean-breaks')
s("amen/4").fit().chop(16).cut(1)
.sometimesBy(.5, ply("2"))
.sometimesBy(.25, mul(speed("-1")))`}
  punchcard
/>

Si nous voulons spécifier l'ordre des samples, nous pouvons remplacer `chop` par `slice` :

<MiniRepl
  client:visible
  tune={`samples('github:yaxu/clean-breaks')
s("amen/4").fit()
  .slice(8, "<0 1 2 3 4*2 5 6 [6 7]>*2")
  .cut(1).rarely(ply("2"))`}
  punchcard
/>

Si nous utilisons `splice` au lieu de `slice`, la vitesse s'ajuste à la durée de l'événement :

<MiniRepl
  client:visible
  tune={`samples('github:yaxu/clean-breaks')
s("amen")
  .splice(8, "<0 1 2 3 4*2 5 6 [6 7]>*2")
  .cut(1).rarely(ply("2"))`}
  punchcard
/>

Notez que nous n'avons pas besoin de `fit`, car `splice` le fera lui-même.

## Enveloppes de Filtre

En utilisant `lpenv`, nous pouvons faire bouger le filtre :

<MiniRepl
  client:visible
  tune={`note("g1 bb1 <c2 eb2> d2")
  .s("sawtooth")
  .lpf(400).lpenv(4)
  .scope()`}
/>

Le type d'enveloppe dépend des méthodes que vous définissez. Définissons `lpa` :

<MiniRepl
  client:visible
  tune={`note("g1 bb1 <c2 eb2> d2")
  .s("sawtooth").lpq(8)
  .lpf(400).lpa(.2).lpenv(4)
  .scope()`}
/>

Maintenant le filtre attaque, plutôt que de décroître comme avant (la décroissance est le comportement par défaut). Nous pouvons aussi faire les deux :

<MiniRepl
  client:visible
  tune={`note("g1 bb1 <c2 eb2> d2")
  .s("sawtooth").lpq(8)
  .lpf(400).lpa(.1).lpd(.1).lpenv(4)
  .scope()`}
/>

Vous pouvez jouer avec `lpa` | `lpd` | `lps` | `lpd` pour voir ce que fera l'enveloppe de filtre.

## Superposer des Sons

Nous pouvons superposer des sons en les séparant par "," :

<MiniRepl
  client:visible
  tune={`note("<g1 bb1 d2 f1>")
.s("sawtooth, square") // <------
.scope()`}
/>

Nous pouvons contrôler le gain de sons individuels comme ceci :

<MiniRepl
  client:visible
  tune={`note("<g1 bb1 d2 f1>")
.s("sawtooth, square:0:.5") // <--- "nom:numéro:gain"
.scope()`}
/>

Pour plus de contrôle sur chaque voix, nous pouvons utiliser `layer` :

<MiniRepl
  client:visible
  tune={`note("<g1 bb1 d2 f1>").layer(
  x=>x.s("sawtooth").vib(4),
  x=>x.s("square").add(note(12))
).scope()`}
/>

Ici, nous donnons un vibrato à la dent de scie et le carré est déplacé d'une octave vers le haut.
Avec `layer`, vous pouvez utiliser n'importe quelle méthode de pattern disponible sur chaque voix, donc les possibilités sont infinies..

## Désaccord d'Oscillateur

Nous pouvons épaissir un son en ajoutant une version désaccordée :

<MiniRepl
  client:visible
  tune={`note("<g1 bb1 d2 f1>")
.add(note("0,.1")) // <------ chorus
.s("sawtooth").scope()`}
  punchcard
/>

Essayez différentes valeurs, ou ajoutez une autre voix !

## Polyrythmes

Voici un exemple simple de polyrythme :

<MiniRepl client:visible tune={`s("bd*2,hh*3")`} punchcard />

Un polyrythme c'est quand 2 tempos différents se produisent en même temps.

## Polymètre

Ceci est un polymètre :

<MiniRepl client:visible tune={`s("<bd rim, hh hh oh>*4")`} punchcard />

Un polymètre c'est quand 2 longueurs de mesure différentes jouent au même tempo.

## Phasage

Ceci est un phasage :

<MiniRepl client:visible tune={`note("<C D G A Bb D C A G D Bb A>*[6,6.1]").piano()`} punchcard />

Le phasage se produit lorsque la même séquence joue à des tempos légèrement différents.

## Parcourir des Samples

En utilisant `run` avec `n`, nous pouvons parcourir une banque de samples :

<MiniRepl
  client:visible
  tune={`samples('bubo:fox')
n(run(8)).s("ftabla")`}
  punchcard
/>

Cela fonctionne très bien avec des banques de samples qui contiennent des sons similaires, comme dans ce cas différents enregistrements d'un tabla.
Souvent, vous entendrez le début de la phrase pas là où le pattern commence.
Dans ce cas, j'entends le début au troisième sample, ce qui peut être compensé avec `early`.

<MiniRepl
  client:visible
  tune={`samples('bubo:fox')
n(run(8)).s("ftabla").early(2/8)`}
/>

Ajoutons un peu d'aléatoire :

<MiniRepl
  client:visible
  tune={`samples('bubo:fox')
n(run(8)).s("ftabla").early(2/8)
.sometimes(mul(speed("1.5")))`}
/>

## Oscillation de Bande

Nous pouvons émuler un effet d'oscillation de hauteur comme ceci :

<MiniRepl
  client:visible
  tune={`note("<c4 bb f eb>*8")
.add(note(perlin.range(0,.5))) // <------ oscillation
.clip(2).s("gm_electric_guitar_clean")`}
/>

## Durée du Son

Il existe plusieurs façons de modifier la durée du son. En utilisant clip :

<MiniRepl
  client:visible
  tune={`note("f ab bb c")
.clip("<2 1 .5 .25>")`}
/>

La valeur de clip est relative à la durée de chaque événement.
Nous pouvons également créer des chevauchements en utilisant release :

<MiniRepl
  client:visible
  tune={`note("f ab bb c")
.release("<2 1 .5 .25>")`}
/>

Cela fera disparaître en douceur chaque son pendant le nombre de secondes donné.
Nous pourrions également rendre les notes plus courtes en utilisant une enveloppe de décroissance :

<MiniRepl
  client:visible
  tune={`note("f ab bb c")
.decay("<2 1 .5 .25>")`}
/>

Lors de l'utilisation de samples, nous avons également `.end` pour couper relativement à la longueur du sample :

<MiniRepl client:visible tune={`s("oh*4").end("<1 .5 .25 .1>")`} />

Comparez cela à clip :

<MiniRepl client:visible tune={`s("oh*4").clip("<1 .5 .25 .1>")`} />

ou decay :

<MiniRepl client:visible tune={`s("oh*4").decay("<1 .5 .25 .1>")`} />

## Synthèse par Table d'Ondes

Vous pouvez boucler un sample avec `loop` / `loopEnd` :

<MiniRepl client:visible tune={`note("<c eb g f>").s("bd").loop(1).loopEnd(.05).gain(.2)`} />

Cela nous permet de jouer les premiers 5% de la grosse caisse comme un synthétiseur !
Pour simplifier le chargement des tables d'ondes, tout sample qui commence par `wt_` sera bouclé automatiquement :

<MiniRepl
  client:visible
  tune={`samples('github:bubobubobubobubo/dough-waveforms')
note("c eb g bb").s("wt_dbass").clip(2)`}
/>

Parcourir différentes tables d'ondes peut également donner des variations intéressantes :

<MiniRepl
  client:visible
  tune={`samples('github:bubobubobubobubo/dough-waveforms')
note("c2*8").s("wt_dbass").n(run(8)).fast(2)`}
/>

...ajout d'une enveloppe de filtre + réverbération :

<MiniRepl
  client:visible
  tune={`samples('github:bubobubobubobubo/dough-waveforms')
note("c2*8").s("wt_dbass").n(run(8))
.lpf(perlin.range(100,1000).slow(8))
.lpenv(-3).lpa(.1).room(.5).fast(2)`}
/>
